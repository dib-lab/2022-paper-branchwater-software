## Background: FracMinHash and sourmash {.page_break_before}

FracMinHash is a bottom-sketch version of ModHash that supports
accurate estimation of overlap and containment between two sequencing
sets (gather paper). In brief, FracMinHash is a lossy compression
approach that reduces data sets in size by a scaled factor S. Sketches
support estimation of overlap, bidirectional containment, and Jaccard
similarity between two data sets. Unlike other common sketching
techniques (MinHash, HyperLogLog), FracMinHash supports these
operations between two data sets of different sizes, and unlike mash
screen and CMash does not require the original data sets.

The open-source sourmash software provides a mature and
well-documented command-line interface to FracMinHash, along with
Python and Rust APIs for loading and using FracMinHash sketches. The
Python layer provides a larger number of UX conveniences on top of the
performant Rust layer. Despite the thread safety of the underlying
Rust code, the CLI and Python library operate in single-threaded mode,
which limits the utility of sourmash in certain corners of design
space.

We note up front that there are several limitations of FracMinHash and
sourmash that affect downstream use cases. The typical scaled
parameters used below do not work well for genomes < 10kb in size. Nor
can divergent genomes be found; based on the k-mer containment to ANI
conversion, we find that MAGsearch works well for finding matches to
genomes within about 10% ANI of the query. Finally, FracMinHash was
developed for shotgun data sets and different parameters would be
required for targeted sequencing data such as amplicon data sets. Some
of these limitations are intrinsic to FracMinHash, and others can be
overcome by parameter tuning and further research.

### MAGsearch represents a specific technical challenge to sourmash

The primary design focus for the sourmash CLI has been on searching
and comparing many genome-sized sketches, e.g. genomes, where for
typical parameters above there are ~1k-10k hashes in the sketch. The
software provides a variety of in-memory and on-disk data structures
for organizing sketches in this size range and can search 100s of
thousands of genome sketches with a single query in minutes in a
single thread on an SSD laptop; more complex algorithms such as the
min-set-cov described in XXX can take a few hours but are still
acceptably performant on real-world data.

This doesnâ€™t work at all for searching 800,000 metagenomes. The main
challenges are (1) many very large data sets that (2) do not easily
fit in memory (3) being queried by 1-1000 query genomes at once. An
additional practical challenge was that much of the sourmash CLI and
Python library UX is designed for end users and is hence slow and not
supportive of batch processing. In particular, the sourmash CLI
and Python library is single-threaded.

One possible solution is a parallel workflow /
scatter-gather. Overhead on shell commands and workflow coordination
was significant, and we decided to implement a purpose-built
multithreaded solution instead.
