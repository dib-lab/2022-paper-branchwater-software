## Background: FracMinHash and sourmash {.page_break_before}

FracMinHash is a bottom-sketch version of ModHash that supports accurate estimation of overlap and containment between two sequencing sets (gather paper). In brief, FracMinHash is a lossy compression approach that reduces data sets in size by a scaled factor S. Sketches support overlap, bidirectional containment, and Jaccard similarity between two data sets. Unlike other common sketching techniques (MinHash, HyperLogLog), FracMinHash supports these operations between two data sets of different sizes, and unlike mash screen and CMash does not require the original data sets.

In practice, FracMinHash consists of comparing collections of 64-bit integers which is in the wheelhouse of computers.

The open-source sourmash software provides a mature and well-documented command-line interface to FracMinHash, along with Python and Rust APIs for loading and using FracMinHash sketches. The Python layer provides a larger number of UX conveniences on top of the performant Rust layer. Despite the thread safety of the underlying Rust code, the CLI and Python library operate in single-threaded mode, which limits the utility of sourmash in certain corners of design space.

We note up front that there are several limitations of FracMinHash and sourmash that affect downstream use cases. The typical scaled parameters used below do not work well for genomes < 10kb in size. Nor can divergent genomes be found; based on the k-mer containment to ANI conversion, we find that MAGsearch works well for finding matches to genomes within about 10% ANI of the query. Finally, FracMinHash was developed for shotgun data sets and different parameters would be required for targeted sequencing data such as amplicon data sets. Some of these limitations are intrinsic to FracMinHash, and others can be overcome by parameter tuning and further research.

### Wort and the SRA digest

Over time we (Luiz :)) has sketched the entire microbial SRA (put query here) at DNA k=21,31,51, scaled=1000 with abundance tracking. The metagenome portion of this is approximately 13 TB in  size. Sketches are CC0. Discuss availability. Describe number, maximum size, mode of sketches.

### Use case: MAGsearch

Given this collection of sketches, collaborators immediately wanted to search it with isolate genome sequences and metagenome-assembled genomes (MAGs). Two early use cases were biogeography and outbreak detection. In both cases we were confronted with the desire to search for 5-100 queries, 

### MAGsearch represents a specific technical challenge to sourmash

The primary design focus for sourmash CLI has been on searching and comparing many genome-sized sketches, e.g. genomes, where for typical parameters above there are ~1k-10k hashes in the sketch. The software provides a variety of in-memory and on-disk data structures for organizing sketches in this size range and can search 100s of thousands of genome sketches with a single query in minutes in a single thread on an SSD laptop; more complex algorithms such as the min-set-cov described in XXX can take a few hours but are still acceptably performant on real-world data.

This doesnâ€™t work at all for searching 800,000 metagenomes. The main challenges are (1) many very large data sets that (2) do not easily fit in memory (3) being queried by 1-1000 query genomes. An additional practical challenge was that much of the sourmash CLI and Python library UX is designed for end users and is hence slow and not supportive of batch processing.

One possible solution is a parallel workflow / scatter-gather. Overhead on shell commands and workflow coordination was significant. Instead luiz wrote rust thing described below.

